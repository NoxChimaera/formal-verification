theory Lab1
imports Main
begin

(* Варианты: 010101 *)

(*
1. Объявить термы при помощи команды term,
    указать их тип, сопроводить ответ 
    нужными комментариями.
Вариант 0. Переменная x типа Bool;
    логическое отрицание x.
*)
term "x::bool"  	(* переменная x типа bool *)
term "\<not>x"   	(* логическое отрицание x *)

(*
2. Проверить, являются ли данные хорошо типизированными,
    если нет, то почему? Имеют ли они смысл?
Вариант 1. логическое И нуля и единицы
*)
(* term "0 \<and> 1" *)   (* Выражение плохо типизировано, 
             так как логическое И определено
             только над типом bool *)

(*
3. Найти значения выражений при помощи команды value.
Вариант 0. Разность 42 и 28;
    Тоже выражение, но обе константы имеют тип nat.
*)
value "42 - 28"  
value "(42::nat) - (28::nat)"

(*
5. Записать указанные числа через 0 и Suc,
    вычислить значения составленных из них выражений
    при помощи value.
Вариант 0. a = 2, b = 3;
    a + b, a * b
*)
(* 2::nat = Suc (Suc 0) *)
(* 3::nat = Suc (Suc (Suc 0 ))*)

value "let a = 2; b = 3::int
  in a + b"

value "let a = 2; b = 3::int
  in a * b"

value "let a = Suc (Suc 0); b = Suc( Suc (Suc 0)) in a + b"

(*
6. Записать выражения в виде лямбда-функций,
    вычислить их значения для указанных аргументов
    при помощи value.
Вариант 1. f(x) = x * 2;
    f(3), где 3 — nat,
    f(w)
    f(u - 1)
*)

value "(\<lambda>x. x + x) 2::nat"
value "(\<lambda>x. x + x) p"
value "(\<lambda>x. x + x) (r + 1)"


primrec mul :: "nat \<Rightarrow> nat \<Rightarrow> nat"
where
  "mul x 0 = 0"
  | "mul x (Suc y) =  x + mul x y"

value "mul 2 3"